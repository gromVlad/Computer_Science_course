//__Computer science во фронтенде__//

// Инженер работает с информации

// База
// Фундаментальные аспекты программирование
// Самые важные и полезные структуры данных
// Роберт Лафор книги
// Функциональные приемы програмирование
// Асинхронное програмирование
// Конкурентное програмирование
// Паралельное вычесление
// Wasm

// Инфаструктура
// Общие лекции про модули и сборку в js
// Лекции по webpack
// Лекции по тестированию playwright

// Архитектура
// Принципы написание хорошего кода
// ОО парадигмы
// Самые важные патерны проектирование
// Макро архитектура приложения
// Профилирование ,отладка и безопасность

//---------------------------------//
// 1.Кодирование информации. 
//Данные, типы и структуры данных.
//Типизация в языках программирования.

// Как представлена информация в компьютере?
// Представлена в бинарном и двоичном смысле ток есть 1 тока нет 0.

// Как устроен вычислитель - вычеслитель можно сделать множеством способами, могут быть как механическим так и программные
// Выполнения орерации над данными
// Устройство ввода и вывода
// Внутренняя память
// Принцип работы

// Классификация вычесления над данными 4 способа по флину
// Sisd классический компьютер есть инструкция и данные
// Мisd много инструкции применяются к одному набору данных ,  на ошибки, как конвейер много раз применяем к одним данным
// Simd одна инсрукция но данных много, если например нужно сложить множество чисел на уровне процессора, типо паралельное програмирование в рамках одного вычислительно ядра 
// Mimd много ядер и каждое ядро работает параллельно и считывает кусочки данных

// Мы очень сильно привязаны как работает наш вычеслитель.

// 18-19 век 
// Мех вычислители - разностные машины типо калькулятор (чарльз бэббидж)
// Аналитическая (чарльз бэббидж) не закончил работу закончил другой человек
// Писали программу под эту аналитическую машину
// Ада Лавлейс пишет первую в мире программу
// Электромеханические вычислители

// 20 век
// Электромеханические вычислители
// Компьютеры
// 4 поколения компьютеров
// Первое поколения основано на электронных лампах
// Эпоха транзисторов
// Но существуют и развиваються другие вычислители

// Отсутствие сигнала ноль если есть сигнал это 1 

// Двоичное кодирование
// В электронном мире есть 2 базовых состояния
// Ток есть или тока нет
// Алфавит из 2 букв 0 и 1
// Каждая этого буква алфавита это бит
// Любую инфу нало как то предоставлять в таком двоичном бинарном виде
// Закодировать

// Допустим
// Закодируем алфавит из 3 латинских букв а в с
// А - 0 0
// В - 0 1
// С - 1 1
// Чтобы раскодировать нужно знать как оно было закодировано

// Почему я не закодировал вот так а 0 в 1 с 11?
// Если мы кодируем какую то информацию нам было удобно чтобы у них был один и тот же размер а так будет непонятно что и зачем идет так как мы знаем какой размер.Либо кодируем размер

// Система счислений
// Описывает как записать число
// Человек привык думать в десятичной системе т.к. 10 пальцев на руках
// Ноль появился позже
// Компьютер понимает только десятичную систему
// Поэтому нам помогает двоичная система счислений
// Разряд считаеться справа налево

// Таблица пример есть двоичное число из 8 бит - 00110001
//2^9 2^8 2^7 2^6 2^5  2^4  2^3 2^2 2^1 2^0
//512 256 128  64  32  16   8   4   2    1
//         0    0   1  1    0   0   0    1
//                 +32 +16              +1
//Двоичное число 00110001 соответсвует десятичному 49

// Важно понять 
// Одну и ту жу информацию можно кодировать по разному
// Чтобы уменьшить энтропию придумали стандарты и спецификации кодировки

// Двойчная запись очень громоздкая
// 11111111 - число 255
// Поэтому используеться 16 ричная система можно записать как ff
// Одна буква в 16 системе заменяет 4 буквы в двоичной
// Еше иногда применяют восьмеричную систему

const binaryNumber = '1111111';
const decimalNumber = parseInt(binaryNumber, 2);
console.log(decimalNumber); // 255
(255).toString(2)//1111111

//литеральная форма
//Ob111111 - 255
//Oо377 - 255
//OxFF - 255

// Минимальная двоичная система в js
// Максимальная система счислений в js - 36 ричная - все буквы + все латинские буквы
// Но на практике обычно используются 2 8 16 система

// Как работают инсрукции
// Вычислитель не знает про смысл данных, согласно инсрукции он из преобразовывает
// Логические орерации
// Арефметические операции
// Есть инсрукции атомарные выполнены на уровне интегральных схем
// Есть также другие которые выстраиваются на основе атомарных инструкций

//Дизъюнкция (логическое ИЛИ)
//Дизъюнкция - это логическая операция, которая возвращает true, если хотя бы один из операндов равен true, и false, если оба операнда равны false.
// Таблица истинности для дизъюнкции (логическое ИЛИ)

// A | B | A OR B
//---|---|---|
// true | true | true
// true | false | true
// false | true | true
// false | false | false
const a = true;
const b = false;
const result = a || b; // true

// Дискретная математика а. д. Плотников книга - рекомендую к прочтению

// Любые данные в компьютере это двоичное число
// Процессор имеет набор инструкции которые преобразуют числа
// Инструкции то же числа
// Фактический любая программа это поток данных
// Cpu пошагово считывает данные и инструкции, он не понимает что за числа и смысл операции
// Есть регистр где он различает данные и инструкции
// Нужна абстракции

// Cpu бывают разные
// Одно и то же число  может быть по разному интерпретировано
// Чтоб ы нк было бардак а придумали архитектуру
// В рамках архитектуры описаны спецификации и есть обратная совместимость.

// Язык ассемблера
// Ассемблер - это программа, которая преобразует исходный код на языке ассемблера в машинный код, который может быть выполнен процессором
// Меняет числа на символические имена
// Возможность использовать десятичные числа
// MOV (ассемблер)- 0010...1110(машинный код)
// У каждой архитектуры свой ассемблер
// Пример1.23

// Дальнейшие развитие
// Ассемблер очень сложный использовать
// Для решения языки высокого уровня
// И для вызова инструкции процессора языки предоставляют набор операторов
// Программа из языка высокого уровня должна быть преобразована в машинный код
// 1 способ заранее преобразуется в машинный код - компиляция
// 2 налету считывает и преобразует - интепритатор

// Проблема разной информации
// Любая информация предоставляется как число
// Процессор не понимает смысл данных
// Чтобы закодировать или раскодировать нужно знать схему кодирование
// Не все инструкции допустимы к тем или иным данным

// Тип информации
// Есть некоторое множество информации
// У элементов есть определенные свойства
// На множестве определим набор доступных операций
// Дадим множеству имя

// Тип и предоставления в памяти
// Предоставления типа зависит от свойств
// Любой тип долже кодироваться и интерпретироваться
// Некоторые типы поддерживаються на уровне процессора или ос

// Проблема кодирование типов
// Любой тип можно кодировать по разному
// Размер занимаемой памяти зависит от кодирование

// Типы и Языки програмирование
// Контракты на уровне языка програмирование
// Яп предоставляют готовые абстракции
// Важно как эти абстракции работают
// От способа кодирование много зависит

// Абстрактный тип
// Тип описывает свойство и операции но не описывает реализацию
// Реализация абстрактного типа называеться конкретной

// Причем тут типизация
// Яп имеет базовый набор типов
// Но может также проверять корректность из использование

// Типизация бывает
// Явная
// Неявная
// Гибридная
// Может быть строгая и нестрогая 
// Статическая и динамическая

// На что влияет
// Количество ошибок можно отловить на этапе написание кода
// Простата написание
// Простата поддержки
// Эффективность работы кода
// Предсказуемость кода

// Алекс ос посмотреть

//